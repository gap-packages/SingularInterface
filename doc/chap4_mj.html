<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (SingularInterface) - Chapter 4: Matrices</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap4"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chapA_mj.html">A</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap4.html">[MathJax off]</a></p>
<p><a id="X812CCAB278643A59" name="X812CCAB278643A59"></a></p>
<div class="ChapSects"><a href="chap4_mj.html#X812CCAB278643A59">4 <span class="Heading">Matrices</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X86EC0F0A78ECBC10">4.1 <span class="Heading">Constructors</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7DE0B8057907F11C">4.1-1 SI_matrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X82E7107E843B1E84">4.1-2 SI_ideal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X801C406286DB3D65">4.1-3 SI_module</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X85239E377E407EE1">4.1-4 SI_vector</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X7DE8E16C7C2D387B">4.2 <span class="Heading">Operations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X83A2DC91817FF3CB">4.2-1 SI_nrows</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X87B229937AC37461">4.2-2 SI_transpose</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X819871277ADE8FA0">4.2-3 SI_det</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X867AF33C841012B3">4.2-4 SI_\[</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X870FC55E83E70298">4.2-5 SI_std</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X78D9870082C9166E">4.2-6 SI_lift</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X801784E18336EAF4">4.2-7 SI_reduce</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X803ED10180062965">4.2-8 SI_syz</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X83B6C6AA83DAA681">4.2-9 SI_modulo</a></span>
</div></div>
</div>

<h3>4 <span class="Heading">Matrices</span></h3>

<p><a id="X86EC0F0A78ECBC10" name="X86EC0F0A78ECBC10"></a></p>

<h4>4.1 <span class="Heading">Constructors</span></h4>

<p>In this section we discuss constructors for <strong class="pkg">Singular</strong> matrices. We also treat the three datatypes <code class="code">ideal</code>, <code class="code">module</code>, and <code class="code">vector</code> in this section as they are in first approximation sparse representations of <strong class="pkg">Singular</strong> matrices.</p>

<p><a id="X7DE0B8057907F11C" name="X7DE0B8057907F11C"></a></p>

<h5>4.1-1 SI_matrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_matrix</code>( <var class="Arg">r</var>, <var class="Arg">rows</var>, <var class="Arg">columns</var>, <var class="Arg">str</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_matrix</code>( <var class="Arg">rows</var>, <var class="Arg">columns</var>, <var class="Arg">polys</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Construct a matrix over the <strong class="pkg">Singular</strong> ring <var class="Arg">r</var> using the string <var class="Arg">str</var>. TODO: describe variants</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := SI_ring( 32003, "x,y,z" );</span>
&lt;singular ring, 3 indeterminates&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := SI_matrix( r, 2, 3, "x,y,z,x^2,y^2,z^2" );</span>
&lt;singular matrix, 2x3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( m );</span>
x, y, z,
x^2,y^2,z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := SI_var( r, 1 );; y := SI_var( r, 2 );; z := SI_var( r, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := SI_matrix( 2, 3, [x,y,z,x^2,y^2,z^2] );</span>
&lt;singular matrix, 2x3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( m );</span>
x, y, z,
x^2,y^2,z^2
</pre></div>

<p><a id="X82E7107E843B1E84" name="X82E7107E843B1E84"></a></p>

<h5>4.1-2 SI_ideal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_ideal</code>( <var class="Arg">r</var>, <var class="Arg">str</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_ideal</code>( <var class="Arg">polys</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Construct an "ideal" in the <strong class="pkg">Singular</strong> ring <var class="Arg">r</var> using the string <var class="Arg">str</var>. TODO: describe variants The datatype <code class="code">ideal</code> in <strong class="pkg">Singular</strong> is in first approximation a specialized data structure for matrices consisting of a single row. However, the print method in <strong class="pkg">Singular</strong> prints them as a single column.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := SI_ring( ); ## = SI_ring( 32003, "x,y,z" );</span>
&lt;singular ring, 3 indeterminates&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := SI_var( r, 1 );; y := SI_var( r, 2 );; z := SI_var( r, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := SI_ideal( [x^2,x*y,z^2] );</span>
&lt;singular ideal, 3 gens&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( I );</span>
x^2,
x*y,
z^2
</pre></div>

<p><a id="X801C406286DB3D65" name="X801C406286DB3D65"></a></p>

<h5>4.1-3 SI_module</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_module</code>( <var class="Arg">mat</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Convert the <strong class="pkg">Singular</strong> matrix <var class="Arg">mat</var> into a <strong class="pkg">Singular</strong> "module". The datatype <code class="code">module</code> in <strong class="pkg">Singular</strong> is in first approximation a specialized sparse data structure for column oriented matrices with compressed columns. Each column has the <strong class="pkg">Singular</strong> datatype <code class="code">vector</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := SI_ring( 32003, "x,y,z" );</span>
&lt;singular ring, 3 indeterminates&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := SI_var( r, 1 );; y := SI_var( r, 2 );; z := SI_var( r, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := SI_matrix( 2, 3, [x,y,z,x^2,y^2,z^2] );</span>
&lt;singular matrix, 2x3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := SI_module( m );</span>
&lt;singular module, 3 vectors in free module of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( M );</span>
x, y, z,
x^2,y^2,z^2
</pre></div>

<p><a id="X85239E377E407EE1" name="X85239E377E407EE1"></a></p>

<h5>4.1-4 SI_vector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_vector</code>( <var class="Arg">r</var>, <var class="Arg">str</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Construct a "vector" over the <strong class="pkg">Singular</strong> ring <var class="Arg">r</var> using the string <var class="Arg">str</var>. The datatype <code class="code">vector</code> in <strong class="pkg">Singular</strong> is in first approximation a specialized sparse data structure for matrices consisting of a single column. However, the print method in <strong class="pkg">Singular</strong> prints them as a single row or rather a list.</p>

<p><a id="X7DE8E16C7C2D387B" name="X7DE8E16C7C2D387B"></a></p>

<h4>4.2 <span class="Heading">Operations</span></h4>

<p><a id="X83A2DC91817FF3CB" name="X83A2DC91817FF3CB"></a></p>

<h5>4.2-1 SI_nrows</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_nrows</code>( <var class="Arg">mat</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_ncols</code>( <var class="Arg">mat</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Compute the number of rows (resp. columns) of the matrix/ideal/module <var class="Arg">mat</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := SI_ring( );</span>
&lt;singular ring, 3 indeterminates&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := SI_matrix( r, 2, 3, "x,y,z,x^2,y^2,z^2" );</span>
&lt;singular matrix, 2x3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( m );</span>
x, y, z,
x^2,y^2,z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_nrows( m );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_ncols( m );</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := SI_ideal( m );</span>
&lt;singular ideal, 6 gens&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( I );</span>
x,
y,
z,
x^2,
y^2,
z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_nrows( I );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_ncols( I );</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i := SI_matrix( I );</span>
&lt;singular matrix, 1x6&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( i );</span>
x,y,z,x^2,y^2,z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := SI_module( m );</span>
&lt;singular module, 3 vectors in free module of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( M );</span>
x, y, z,
x^2,y^2,z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_nrows( M );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_ncols( M );</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v0 := SI_vector( r, "0,0,0,0" );</span>
&lt;singular vector, 0 entries&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( v0 );</span>
[0]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v2 := SI_vector( r, "0,x,0,0" );</span>
&lt;singular vector, 2 entries&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( v2 );</span>
[0,x]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v3 := SI_vector( r, "0,x,y^2,0" );</span>
&lt;singular vector, 3 entries&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( v3 );</span>
[0,x,y^2]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v4 := SI_vector( r, "0,x,y^2,z^3" );</span>
&lt;singular vector, 4 entries&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( v4 );</span>
[0,x,y^2,z^3]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_ncols( v0 ); SI_ncols( v2 ); SI_ncols( v3 ); SI_ncols( v4 );</span>
1
1
1
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_nrows( v0 ); SI_nrows( v2 ); SI_nrows( v3 ); SI_nrows( v4 );</span>
0
2
3
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bim := SI_bigintmat( [[1,2,3],[4,5,6]] );</span>
&lt;singular bigintmat:[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( bim );</span>
1,2,3,
4,5,6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_nrows( bim );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_ncols( bim );</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iv := SI_intvec( [ 1, 2, 3, 0 ] );</span>
&lt;singular intvec:[ 1, 2, 3, 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( iv );</span>
1,
2,
3,
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_nrows( iv );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_ncols( iv );</span>
fail
</pre></div>

<p><a id="X87B229937AC37461" name="X87B229937AC37461"></a></p>

<h5>4.2-2 SI_transpose</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_transpose</code>( <var class="Arg">mat</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransposedMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Return the transposed matrix of the matrix <var class="Arg">mat</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := SI_ring( );</span>
&lt;singular ring, 3 indeterminates&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := SI_matrix( r, 2, 3, "x,y,z,x^2,y^2,z^2" );</span>
&lt;singular matrix, 2x3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( m );</span>
x, y, z,
x^2,y^2,z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := SI_transpose( m );</span>
&lt;singular matrix, 3x2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t );</span>
x,x^2,
y,y^2,
z,z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := SI_ideal( m );</span>
&lt;singular ideal, 6 gens&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( I );</span>
x,
y,
z,
x^2,
y^2,
z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i := SI_matrix( I );</span>
&lt;singular matrix, 1x6&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( i );</span>
x,y,z,x^2,y^2,z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_transpose( I );</span>
&lt;singular matrix, 6x1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := SI_module( m );</span>
&lt;singular module, 3 vectors in free module of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( M );</span>
x, y, z,
x^2,y^2,z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := SI_transpose( M );</span>
&lt;singular module, 2 vectors in free module of rank 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N );</span>
x,x^2,
y,y^2,
z,z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v0 := SI_vector( r, "0,0,0,0" );</span>
&lt;singular vector, 0 entries&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( v0 );</span>
[0]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t0 := SI_transpose( v0 );</span>
&lt;singular matrix, 1x1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t0 );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v2 := SI_vector( r, "0,x,0,0" );</span>
&lt;singular vector, 2 entries&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( v2 );</span>
[0,x]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2 := SI_transpose( v2 );</span>
&lt;singular matrix, 1x2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t2 );</span>
0,x
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v3 := SI_vector( r, "0,x,y^2,0" );</span>
&lt;singular vector, 3 entries&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( v3 );</span>
[0,x,y^2]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t3 := SI_transpose( v3 );</span>
&lt;singular matrix, 1x3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t3 );</span>
0,x,y^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v4 := SI_vector( r, "0,x,y^2,z^3" );</span>
&lt;singular vector, 4 entries&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( v4 );</span>
[0,x,y^2,z^3]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t4 := SI_transpose( v4 );</span>
&lt;singular matrix, 1x4&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( t4 );</span>
0,x,y^2,z^3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bim := SI_bigintmat( [[1,2,3],[4,5,6]] );</span>
&lt;singular bigintmat:[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( bim );</span>
1,2,3,
4,5,6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tim := SI_transpose( bim );</span>
&lt;singular bigintmat:[ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( tim );</span>
1,4,
2,5,
3,6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iv := SI_intvec( [ 1, 2, 3, 0 ] );</span>
&lt;singular intvec:[ 1, 2, 3, 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( iv );</span>
1,
2,
3,
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tv := SI_transpose( iv );</span>
&lt;singular intmat:[ [ 1, 2, 3, 0 ] ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( tv );</span>
1 2 3 0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_transpose( tv );</span>
&lt;singular intmat:[ [ 1 ], [ 2 ], [ 3 ], [ 0 ] ]&gt;
</pre></div>

<p><a id="X819871277ADE8FA0" name="X819871277ADE8FA0"></a></p>

<h5>4.2-3 SI_det</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_det</code>( <var class="Arg">mat</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Determinant</code>( <var class="Arg">mat</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DeterminantMat</code>( <var class="Arg">mat</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Return the determinant of the square matrix <var class="Arg">mat</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := SI_ring( );</span>
&lt;singular ring, 3 indeterminates&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := SI_matrix( r, 2, 3, "x,y,z,x^2,y^2,z^2" );</span>
&lt;singular matrix, 2x3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( m );</span>
x, y, z,
x^2,y^2,z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := m * SI_transpose( m );</span>
&lt;singular matrix, 2x2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_det( n );</span>
x^4*y^2-2*x^3*y^3+x^2*y^4+x^4*z^2+y^4*z^2-2*x^3*z^3-2*y^3*z^3+x^2*z^4+y^2*z^4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := SI_module( n );</span>
&lt;singular module, 2 vectors in free module of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_det( N );</span>
x^4*y^2-2*x^3*y^3+x^2*y^4+x^4*z^2+y^4*z^2-2*x^3*z^3-2*y^3*z^3+x^2*z^4+y^2*z^4
</pre></div>

<p><a id="X867AF33C841012B3" name="X867AF33C841012B3"></a></p>

<h5>4.2-4 SI_\[</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_\[</code>( <var class="Arg">mat</var>, <var class="Arg">i</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; \[\]</code>( <var class="Arg">mat</var>, <var class="Arg">i</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The syntax <var class="Arg">mat</var><code class="code">[</code><var class="Arg">i</var><code class="code">]</code> is a shorthand for <code class="code">SI_\[(</code><var class="Arg">mat</var>,<var class="Arg">i</var><code class="code">)</code>. If <var class="Arg">mat</var> is of type</p>


<ul>
<li><p><code class="code">matrix</code> then return <var class="Arg">i</var>-th column as a <code class="code">vector</code>.</p>

</li>
<li><p><code class="code">module</code> then return <var class="Arg">i</var>-th column as a <code class="code">vector</code>.</p>

</li>
<li><p><code class="code">ideal</code> then return <var class="Arg">i</var>-th entry as a <code class="code">poly</code>.</p>

</li>
<li><p><code class="code">vector</code> then return <var class="Arg">i</var>-th entry as a <code class="code">poly</code>.</p>

</li>
</ul>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := SI_ring( );</span>
&lt;singular ring, 3 indeterminates&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := SI_matrix( r, 2, 3, "x,y,0,z^2,0,0" );</span>
&lt;singular matrix, 2x3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( m );</span>
x, y,0,
z^2,0,0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m1 := m[1];</span>
&lt;singular vector, 2 entries&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( m1 );</span>
[x,z^2]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m2 := m[2];</span>
&lt;singular vector, 1 entry&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( m2 );</span>
[y]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m3 := m[3];</span>
&lt;singular vector, 0 entries&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( m3 );</span>
[0]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := SI_module( m );</span>
&lt;singular module, 3 vectors in free module of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M1 := M[1];</span>
&lt;singular vector, 2 entries&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( M1 );</span>
[x,z^2]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M[1][2];</span>
z^2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M2 := M[2];</span>
&lt;singular vector, 1 entry&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( M2 );</span>
[y]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M3 := M[3];</span>
&lt;singular vector, 0 entries&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( M3 );</span>
[0]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := SI_ideal( m );</span>
&lt;singular ideal, 6 gens&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( I );</span>
x,
y,
0,
z^2,
0,
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I[1]; I[6];</span>
x
0
</pre></div>

<p><a id="X870FC55E83E70298" name="X870FC55E83E70298"></a></p>

<h5>4.2-5 SI_std</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_std</code>( <var class="Arg">mat</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Compute the standard basis of the columns of the matrix <var class="Arg">mat</var>, which can be of type <code class="code">matrix</code>, <code class="code">module</code>, or <code class="code">ideal</code>.</p>

<p>This holds for commutative rings. For noncommutative rings provided by <strong class="pkg">Plural</strong> the result is the transposed of the standard basis of the rows of the transposed of <var class="Arg">mat</var> (see also Section <a href="chap1_mj.html#X795810197E2E8B18"><span class="RefLink">1.4</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := SI_ring( 0, "x0..3" );</span>
&lt;singular ring, 4 indeterminates&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_option( "redTail" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := SI_ideal( R, "x0^2-x1*x3, x0*x1-x2*x3" );</span>
&lt;singular ideal, 2 gens&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( I );</span>
x0^2-x1*x3,
x0*x1-x2*x3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := SI_std( I );</span>
&lt;singular ideal, 3 gens&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( J );</span>
x0*x1-x2*x3,
x0^2-x1*x3,
x1^2*x3-x0*x2*x3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := SI_matrix( R, 3, 4, "x0,x1*x3,x0,x3, -x1,-x2*x3,x1,x2, -1,-x0,x3,x0" );</span>
&lt;singular matrix, 3x4&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( m );</span>
x0, x1*x3, x0,x3,
-x1,-x2*x3,x1,x2,
-1, -x0, x3,x0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := SI_std( m );</span>
&lt;singular module, 6 vectors in free module of rank 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( g );</span>
0, x3,x0,x1*x3+x3, 0, x2*x3^3-x2*x3,
2*x1,x2,x1,-x2*x3+x2,2*x0*x2*x3-2*x0*x2, x2^2*x3^2-x2^2,
x3+1,x0,x3,0, x1*x3^2-x1*x3+x3^2-x3,x1^2*x3^2-x1^2*x3+x1*x3^2-x1*x3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := SI_module( m );</span>
&lt;singular module, 4 vectors in free module of rank 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SI_std( M );</span>
&lt;singular module, 6 vectors in free module of rank 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( G );</span>
0, x3,x0,x1*x3+x3, 0, x2*x3^3-x2*x3,
2*x1,x2,x1,-x2*x3+x2,2*x0*x2*x3-2*x0*x2, x2^2*x3^2-x2^2,
x3+1,x0,x3,0, x1*x3^2-x1*x3+x3^2-x3,x1^2*x3^2-x1^2*x3+x1*x3^2-x1*x3
</pre></div>

<p><a id="X78D9870082C9166E" name="X78D9870082C9166E"></a></p>

<h5>4.2-6 SI_lift</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_lift</code>( <var class="Arg">mat</var>, <var class="Arg">std</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The matrix <var class="Arg">std</var> is assumed to be the output of <code class="code">SI_std</code> and the number of rows of <var class="Arg">mat</var> and <var class="Arg">std</var> must coincide. If the columns of <var class="Arg">mat</var> are linear combinations of the columns of <var class="Arg">std</var> then the resulting matrix <span class="SimpleMath">\(T\)</span> satisfies the matrix equation <span class="SimpleMath">\(\textit{mat} * T = \textit{std}\)</span>.</p>

<p>This holds for commutative rings. For noncommutative rings provided by <strong class="pkg">Plural</strong> an inequivalent equality holds: <code class="code">SI_transpose(</code>T<code class="code">)</code> <span class="SimpleMath">\(*\)</span> <code class="code">SI_transpose(</code><var class="Arg">mat</var><code class="code">)</code> <span class="SimpleMath">\(=\)</span> <code class="code">SI_transpose(</code><var class="Arg">std</var><code class="code">)</code>, which is equivalent to <code class="code">SI_transpose(SI_transpose(</code>T<code class="code">)</code> <span class="SimpleMath">\(*\)</span> <code class="code">SI_transpose(</code><var class="Arg">mat</var><code class="code">))</code> <span class="SimpleMath">\(=\)</span> <var class="Arg">std</var> but not to <span class="SimpleMath">\(\textit{mat} * T = \textit{std}\)</span> if the ring is noncommutative (see also Section <a href="chap1_mj.html#X795810197E2E8B18"><span class="RefLink">1.4</span></a>).</p>

<p><a id="X801784E18336EAF4" name="X801784E18336EAF4"></a></p>

<h5>4.2-7 SI_reduce</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_reduce</code>( <var class="Arg">mat</var>, <var class="Arg">std</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The matrix <var class="Arg">std</var> is assumed to be the output of <code class="code">SI_std</code> and the number of rows of <var class="Arg">mat</var> and <var class="Arg">std</var> must coincide. The output is a matrix having the same shape as <var class="Arg">mat</var>. It columns are the reductions of the columns of <var class="Arg">mat</var> modulo those of <var class="Arg">std</var>.</p>

<p><a id="X803ED10180062965" name="X803ED10180062965"></a></p>

<h5>4.2-8 SI_syz</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_syz</code>( <var class="Arg">mat</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Compute the matrix of column syzygies of the matrix <var class="Arg">mat</var>, which can be of type <code class="code">matrix</code>, <code class="code">module</code>, or <code class="code">ideal</code>.</p>

<p>This holds for commutative rings. For noncommutative rings provided by <strong class="pkg">Plural</strong> and <strong class="pkg">SCA</strong> the result is the transposed of the matrix of row syzygies of the transposed of <var class="Arg">mat</var>. We refer the reader to the documentation of the corresponding procedure in the <strong class="pkg">Plural</strong> manual (see also Section <a href="chap1_mj.html#X795810197E2E8B18"><span class="RefLink">1.4</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := SI_ring( 0, "x0..3" );</span>
&lt;singular ring, 4 indeterminates&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SI_option( "redTail" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := SI_ideal( R, "x0^2-x1*x3, x0*x1-x2*x3" );</span>
&lt;singular ideal, 2 gens&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( I );</span>
x0^2-x1*x3,
x0*x1-x2*x3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := SI_syz( I );</span>
&lt;singular module, 1 vector in free module of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( K );</span>
-x0*x1+x2*x3,
x0^2-x1*x3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := SI_std( I );</span>
&lt;singular ideal, 3 gens&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( J );</span>
x0*x1-x2*x3,
x0^2-x1*x3,
x1^2*x3-x0*x2*x3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SI_syz( J );</span>
&lt;singular module, 2 vectors in free module of rank 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S );</span>
x0, x1*x3,
-x1,-x2*x3,
-1, -x0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2 := SI_syz( S );</span>
&lt;singular module, 1 vector in free module of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( S2 );</span>
0,
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">j := SI_matrix( J );</span>
&lt;singular matrix, 1x3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := SI_syz( j );</span>
&lt;singular module, 2 vectors in free module of rank 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( s );</span>
x0, x1*x3,
-x1,-x2*x3,
-1, -x0
</pre></div>

<p><a id="X83B6C6AA83DAA681" name="X83B6C6AA83DAA681"></a></p>

<h5>4.2-9 SI_modulo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SI_modulo</code>( <var class="Arg">mat</var>, <var class="Arg">rel</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The number of rows of the matrices <var class="Arg">mat</var> and <var class="Arg">rel</var> must coincide. The procedures returns the column syzygies of <var class="Arg">mat</var> modulo the columns of <var class="Arg">rel</var>.</p>

<p>This holds for commutative rings. For noncommutative rings provided by <strong class="pkg">Plural</strong> and <strong class="pkg">SCA</strong> we refer the reader to the documentation of the corresponding procedure in the <strong class="pkg">Plural</strong> manual (see also Section <a href="chap1_mj.html#X795810197E2E8B18"><span class="RefLink">1.4</span></a>).</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chapA_mj.html">A</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
