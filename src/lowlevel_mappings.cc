// DO NOT EDIT THIS FILE BY HAND IT IS MACHINE GENERATED
#include "lowlevel_mappings.h"

#ifdef __cplusplus
extern "C" {
#endif /* ifdef __cplusplus */

Obj Func_SI_p_String(Obj self, Obj arg1) {
    UInt rnr;
    ring r = currRing;
    
    // Prepare input data
    SingObj obj1(arg1, rnr, r);
    if (obj1.error) {
        obj1.cleanup();
        ErrorQuit(obj1.error,0L,0L);
        return Fail;
    } else if (obj1.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        ErrorQuit("argument 1 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var1 = (poly) obj1.nondestructiveuse();
    
    // Call into Singular kernel
    char * res = p_String(var1,r);
    
    // Convert result for GAP and return it
    {
        UInt len = (UInt) strlen(res);
        Obj tmp = NEW_STRING(len);
        SET_LEN_STRING(tmp,len);
        strcpy(reinterpret_cast<char*>(CHARS_STRING(tmp)),res);
        return tmp;
    }
}

Obj Func_SI_p_Neg(Obj self, Obj arg1) {
    UInt rnr;
    ring r = currRing;
    
    // Prepare input data
    SingObj obj1(arg1, rnr, r);
    if (obj1.error) {
        obj1.cleanup();
        ErrorQuit(obj1.error,0L,0L);
        return Fail;
    } else if (obj1.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        ErrorQuit("argument 1 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var1 = (poly) obj1.destructiveuse();
    
    // Call into Singular kernel
    poly res = p_Neg(var1,r);
    
    // Convert result for GAP and return it
    {
        Obj tmp = NEW_SINGOBJ_RING(SINGTYPE_POLY,res,rnr);
        return tmp;
    }
}

Obj Func_SI_pp_Mult_qq(Obj self, Obj arg1, Obj arg2) {
    UInt rnr;
    ring r = currRing;
    
    // Prepare input data
    SingObj obj1(arg1, rnr, r);
    if (obj1.error) {
        obj1.cleanup();
        ErrorQuit(obj1.error,0L,0L);
        return Fail;
    } else if (obj1.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        ErrorQuit("argument 1 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var1 = (poly) obj1.nondestructiveuse();
    SingObj obj2(arg2, rnr, r);
    if (obj2.error) {
        obj1.cleanup();
        obj2.cleanup();
        ErrorQuit(obj2.error,0L,0L);
        return Fail;
    } else if (obj2.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        obj2.cleanup();
        ErrorQuit("argument 2 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var2 = (poly) obj2.nondestructiveuse();
    
    // Call into Singular kernel
    poly res = pp_Mult_qq(var1,var2,r);
    
    // Convert result for GAP and return it
    {
        Obj tmp = NEW_SINGOBJ_RING(SINGTYPE_POLY,res,rnr);
        return tmp;
    }
}

Obj Func_SI_pp_Mult_nn(Obj self, Obj arg1, Obj arg2) {
    UInt rnr;
    ring r = currRing;
    
    // Prepare input data
    SingObj obj1(arg1, rnr, r);
    if (obj1.error) {
        obj1.cleanup();
        ErrorQuit(obj1.error,0L,0L);
        return Fail;
    } else if (obj1.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        ErrorQuit("argument 1 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var1 = (poly) obj1.nondestructiveuse();
    SingObj obj2(arg2, rnr, r);
    if (obj2.error) {
        obj1.cleanup();
        obj2.cleanup();
        ErrorQuit(obj2.error,0L,0L);
        return Fail;
    } else if (obj2.obj.rtyp != NUMBER_CMD) {
        obj1.cleanup();
        obj2.cleanup();
        ErrorQuit("argument 2 must be of type NUMBER", 0L, 0L);
        return Fail;
    }
    number var2 = (number) obj2.nondestructiveuse();
    
    // Call into Singular kernel
    poly res = pp_Mult_nn(var1,var2,r);
    
    // Convert result for GAP and return it
    {
        Obj tmp = NEW_SINGOBJ_RING(SINGTYPE_POLY,res,rnr);
        return tmp;
    }
}

Obj Func_SI_p_Add_q(Obj self, Obj arg1, Obj arg2) {
    UInt rnr;
    ring r = currRing;
    
    // Prepare input data
    SingObj obj1(arg1, rnr, r);
    if (obj1.error) {
        obj1.cleanup();
        ErrorQuit(obj1.error,0L,0L);
        return Fail;
    } else if (obj1.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        ErrorQuit("argument 1 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var1 = (poly) obj1.destructiveuse();
    SingObj obj2(arg2, rnr, r);
    if (obj2.error) {
        obj1.cleanup();
        obj2.cleanup();
        ErrorQuit(obj2.error,0L,0L);
        return Fail;
    } else if (obj2.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        obj2.cleanup();
        ErrorQuit("argument 2 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var2 = (poly) obj2.destructiveuse();
    
    // Call into Singular kernel
    poly res = p_Add_q(var1,var2,r);
    
    // Convert result for GAP and return it
    {
        Obj tmp = NEW_SINGOBJ_RING(SINGTYPE_POLY,res,rnr);
        return tmp;
    }
}

Obj Func_SI_p_Minus_mm_Mult_qq(Obj self, Obj arg1, Obj arg2, Obj arg3) {
    UInt rnr;
    ring r = currRing;
    
    // Prepare input data
    SingObj obj1(arg1, rnr, r);
    if (obj1.error) {
        obj1.cleanup();
        ErrorQuit(obj1.error,0L,0L);
        return Fail;
    } else if (obj1.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        ErrorQuit("argument 1 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var1 = (poly) obj1.destructiveuse();
    SingObj obj2(arg2, rnr, r);
    if (obj2.error) {
        obj1.cleanup();
        obj2.cleanup();
        ErrorQuit(obj2.error,0L,0L);
        return Fail;
    } else if (obj2.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        obj2.cleanup();
        ErrorQuit("argument 2 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var2 = (poly) obj2.nondestructiveuse();
    SingObj obj3(arg3, rnr, r);
    if (obj3.error) {
        obj1.cleanup();
        obj2.cleanup();
        obj3.cleanup();
        ErrorQuit(obj3.error,0L,0L);
        return Fail;
    } else if (obj3.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        obj2.cleanup();
        obj3.cleanup();
        ErrorQuit("argument 3 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var3 = (poly) obj3.nondestructiveuse();
    
    // Call into Singular kernel
    poly res = p_Minus_mm_Mult_qq(var1,var2,var3,r);
    
    // Convert result for GAP and return it
    {
        Obj tmp = NEW_SINGOBJ_RING(SINGTYPE_POLY,res,rnr);
        return tmp;
    }
}

Obj Func_SI_p_Plus_mm_Mult_qq(Obj self, Obj arg1, Obj arg2, Obj arg3) {
    UInt rnr;
    ring r = currRing;
    
    // Prepare input data
    SingObj obj1(arg1, rnr, r);
    if (obj1.error) {
        obj1.cleanup();
        ErrorQuit(obj1.error,0L,0L);
        return Fail;
    } else if (obj1.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        ErrorQuit("argument 1 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var1 = (poly) obj1.destructiveuse();
    SingObj obj2(arg2, rnr, r);
    if (obj2.error) {
        obj1.cleanup();
        obj2.cleanup();
        ErrorQuit(obj2.error,0L,0L);
        return Fail;
    } else if (obj2.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        obj2.cleanup();
        ErrorQuit("argument 2 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var2 = (poly) obj2.nondestructiveuse();
    SingObj obj3(arg3, rnr, r);
    if (obj3.error) {
        obj1.cleanup();
        obj2.cleanup();
        obj3.cleanup();
        ErrorQuit(obj3.error,0L,0L);
        return Fail;
    } else if (obj3.obj.rtyp != POLY_CMD) {
        obj1.cleanup();
        obj2.cleanup();
        obj3.cleanup();
        ErrorQuit("argument 3 must be of type POLY", 0L, 0L);
        return Fail;
    }
    poly var3 = (poly) obj3.nondestructiveuse();
    
    // Call into Singular kernel
    poly res = p_Plus_mm_Mult_qq(var1,var2,var3,r);
    
    // Convert result for GAP and return it
    {
        Obj tmp = NEW_SINGOBJ_RING(SINGTYPE_POLY,res,rnr);
        return tmp;
    }
}


#ifdef __cplusplus
}
#endif /* ifdef __cplusplus */
